class: middle center

# Lua 101

## We have to start somewhere!

---

# Running the interpretor

- Lua source usually in `source.lua` files
- From the command line: `lua source.lua` (or `lua.exe source.lua` on Windows, depending on the installation)
- From a menu (or shortcut) in a Lua-friendly text editor
- one program = one Lua file (for now)
- interpreter reads the whole file and executes it (a "chunck")

---

# Before we really start

Comments: ignored by the interpretor

```lua
-- till the end of line
--[[till the closing brackets]]
--[==[till the closing matched brackets]==]
```

The `print` function: basic way to output (can take any type as argument)

```lua
print(5 + 6)            -- output: 11
print("This is great!") -- output: This is great!
print(1, nil, true)     -- output: 1    nil    true
```

Assignment to a variable (details to come)

```lua
a = 6
print(a)    -- output: 6
```

---

# Basic types and literals

> type (computing): a classification or category of various types of data, that states the possible values that can be taken, how they are stored, and what range of operations are allowed on them

Number

```lua
4     0.4     4.57e-3     0.3e12     5e+20     0xabcd1234
```

Internally: double precision floating point numbers

- integers from 0 to 2^53
- real numbers from 4.9e-324 to 1.79e308, with ~17 significant digits
- infinity
- NaN ("not a number")
- negative versions of all of these

---

# Basic types and literals (2)

String: a sequence of characters representing text

```lua
'blah blah'     -- single quoted
"blah blah"     -- double quoted
[[blah blah]]   -- long string

"This is a singly quoted word: 'horse'"
'Bob said: "Hi, I am Bob!"'
[[Bob said: "Hi, I'm Bob!"]]
```

Escapes: `\t` (tab), `\n` (new line), `\\`, `\'`, `\"`, `\[`,`\]`.

In a long string, every character represents itself (doesn't escape anything and allows newlines)

```lua
a = [[multiline
stuff with unescaped
things: \'\\\t']]
```

---

# Basic types and literals (3)

Boolean: represents a truth value, can take exactly two values (true and false).

Corresponding literals:

- `true`
- `false`

Used in logic and to make branching decisions (what part of the code to execute).

```lua
a = true
print(a)   -- true
a = false
print(a)   -- false
```

---

# Basic types and literals (4)

Nil: absence of value

Any unused variable "contains" `nil`. We can assign `nil` explicitely to "forget" data.

```lua
print(a)    -- nil
a = 5
print(a)    -- 5
a = nil
print(a)    --- nil
```

Functions that do not return anything "return `nil`":

```lua
a = print("whatever")   -- whatever
print(a)                -- nil
```

---

# Basic types and literals (5)

That was the four basic types: number, string, boolean, nil.

The `type` function returns the type of its argument as a string:

```lua
print(type(5))        -- number
print(type("foo"))    -- string
print(type(a))        -- nil
a = true
print(type(a))        -- boolean
```

A variable doesn't have a type. Only its current value has. Lua is a *dynamically typed* language.

---

# Expressions

An expression is anything that has a value, and therefore, a type. Basic expressions are:

- variables
- literals

Expressions are built by combining smaller expressions with *operators*:

- binary (connects two expressions): `expression operator expression`
- unary (tranforms one expression into another): `operator expression`

Expressions can be grouped in parentheses when the meaning is ambiguous: `(expression)`

---

# Expressions (2)

Arithmetic operators operate on numbers:

```lua
a = 5 + 6       -- addition
b = 4 - a       -- substraction
c = b * b       -- multiplication
print(c / 2)    -- division
d = -c          -- (unary) negation
```

Other arithmetic operators:

```lua
print(2^10)     -- 1024 (exponentiation)
print(5 % 2)    -- 1 (remainder of division)
```

---

# Expressions (3)

We can nest expressions as much as wanted:

```lua
b = 1e3
a = 5 + 4 * 2 - ((7 + b) / 15)
print(a)    -- -54.133333333333
```

Operators `*` and `/` have *precedence* over `+` and `-` (like in math):

- `a * b + c` is `(a * b) + c`

Unary negation has precedence over all others:

- `- a * - b` is `(-a) * (-b)`.

When in doubt: parentheses!

---

# Expressions (4)

Relational operators *compare* things, and return booleans ("is this true or not?")

Order:

- `a < b`: is a strictly smaller than b?
- `a > b`: is a strictly greater than b?
- `a <= b`: is a smaller or equal to b?
- `a >= b`: is a greater or equal to b?

Works for numbers (natural order), and strings (lexicographic order).

```lua
print(5 < 10)                 -- true
print("rap" <= "rock'n'roll") -- true
print(5 >= "music")           -- error: attempt to
                              -- compare string with number
```

---

# Expressions (5)

Equality:

- `a == b`: is `a` equal to `b`?
- `a ~= b`: is `a` different than `b`?

Works for any types. Two values of different types will always be different, though.

```lua
print(5 == 2.5 * 2)            -- true
print(5 == "5")                -- false
print(type("meh") == "string") -- true
print((5 < 10) == true)        -- true
print(foo ~= nil)              -- false
```

Note: `==` is the comparison operator, `=` is for assignment.

---

# Expressions (6)

Logical operators: operate on booleans.

- `a and b` is true is both `a` and `b` are true
- `a or b` is true if either `a` or `b` is true, or both
- `not a` is true if `a` is false, and vice versa

```lua
x = 5
print(x >= 0 and x <= 10)   -- is x between 0 and 10 included?
print(x % 2 == 0)           -- is x an even number?
```

Note that, among other things:

```lua
a ~= b == not(a == b)
a <= b == a < b or a == b
a <= b == not(a > b)
not(not a) == a
```

---

# Expressions (7)

String operators:

- `a .. b`: concatenation (`a` followed by `b`)
- `#a`: length (number of characters in `a`)

```lua
foo = "This is" .. " great!"
foo = foo .. " Isn't it?"
print(foo)                  -- This is great! Isn't it?
print(#foo)                 -- 24
print(#"")                  -- 0
print(foo .. "" == foo)     -- true
```

---

# Expressions (8)

Precedence table for all operators (from low precedence to high precedence):

```lua
or
and
<     >     <=    >=    ~=    ==
..
+     -
/     *     %
not   #     - (unary)
^
```

All binary operators left-associative: `a ? b ? c ? d == (((a ? b) ? c) ? d`, except `..` and `^` which are right associative:

```lua
print(2^3^2)    -- 512
print((2^3)^2)  -- 64
```

When in doubt: parentheses!

---

# Type coercion

Number to string:

```lua
print("Twas the summer of " .. 70 - 1)    -- 69
print(10 .. 11)     -- 1011
```

String to number:

```lua
print(100 + "5")    -- 105
print("0xf1" + 2)   -- 243
print("5" + "2e3")  -- 2005
print("lol" + 4)    -- error: attempt to perform
                    -- arithmetic on a string value
```

When in doubt, use `tostring()` and `tonumber()`.

```lua
print(tonumber("1e4"))      -- 10000
print(tonumber("haha"))     -- nil
```

---

# Type coercion (2)

Anything to boolean:

> `nil` and `false` are false, anything else is true

```lua
print("yay" and 4 == 2 * 2) -- true
print("false" and true)     -- true
print(nil or true)          -- true
```

Real meanings of `and` and `or`:

- `a and b`: if `a` is true, return `b`, else, return `a`
- `a or b`: if `a` is true, return `a`, else, return `b`

```lua
print(true and 5)           -- 5
print(nil and true)         -- nil
print(false or "awesome")   -- "awesome"
print(200 or whatever)      -- 200
```

---

# Type coercion (3)

"Lazy evaluation": the unnecessary expressions are not even evaluated:

```lua
a = 50 or print("nope")     -- a = 50, nothing is printed
b = false and error()       -- b = false, no error
```

(Note: a function returns a value, so a function call is an expression)

Useful idiom: `condition and value or alternative`. If `condition` is true, `value` will be returned. Else, `alternative` is.

```lua
print(true and 5 or 10)     -- 5
print(false and 5 or 10)    -- 10

numCats = 10
str = "I have " .. numCats .. " cat"
str = str .. (numCats > 1 and "s" or "")
print(str)
```

---

# Statements

- a program (in imperative programming) is a sequence of *statements*
- statement: an instruction for the computer to execute, that changes the program's *state*
- state of program: the content of memory, peripherals, and the current location in the code 

Kinds of statements in Lua:

- function call: executing other pieces of code
- assignment: storing values in variables
- flow control: choosing what code to execute depending on some conditions

---

# Statements (2)

We've seen a few standard functions of Lua:

- `print`, which outputs its argument to the console
- `type`, which returns the type of its argument as a string
- `tonumber` and `tostring`, which convert their arguments to number and string
- many more
- our own functions! (later)

A function call, by itself, is a statement:

```lua
-- a valid program, which prints "foo"
print("foo")
tonumber("200")
type(3)
```

Note: a function call can also be an expression, as we've seen.
Note 2: the value returned by the function, if any, is lost (but the function itself is still executed).

---

# Statements (3)

Assignment

- syntax: `identifier = expression`
- meaning: "evaluate `expression`, and store result in variable `identifier`"

A variable is a space in memory which has a name, and contains a value. When we use the variable name later in an expression, the value is retrieved from memory, and used to evaluate the expression:

```lua
a = 5           -- store the number 5 in a variable called a
print(a + 4)    -- retrieve the value stored in a,
                -- add 4 to it, and pass the result to function
                -- print
```

Note: an identifier (variable's name) then can contain letters, numbers, and `_`, but cannot start with a number: `_fooBar`, `l33tH4xorz`, `camelCase`, `classic_case`, `Weird_Mix2`...

---

# Statements (3)

Multiple assignment:

- `comma separated variables = comma separated expressions`
- all expressions (right hand side) evaluated first
- all values assigned then

```lua
x, y = 1, 2
x, y = y, x
print(x, y)     -- 2    1
```

Some functions can return multiple values, caught using multiple assignment:

```lua
integral, fractional = math.modf(2.5)
print(integral, fractional)   -- 2   0.5
```

---

# Statements (4)

Conditional statements: `if then else`

```lua
if condition then
    -- statements
end

if condition then
    -- statements
else
    -- statements
end

if condition then
    -- statements
elseif condition2 then
    -- statements
end
```

- `elseif` and `else` blocks optional.
- `else` block always last

---

# Statements (5)

```lua
if x > 10 then
    print("x > 10")
else
    print("x <= 10")
end
```

Remember boolean evaluation ("false and nil are false, everything else is true"):

```lua
if foo then
    print("foo is not empty")
elseif foo == false then
    print("foo is false")
else
    print("foo is nil")
end
```

---

# Statements (6)

A *block* can be any number of statements...

```lua
if x == 10 then
    doThis()
    doThat()
    if danceFloor then
        danceALitteJig()
    end
end

...including none:

```lua
if foo then
    -- well, that is useful...
end
```

---

# Statements (7)

You can nest as deep as you want...

```lua
if a then
    if b then
        if c then
            if d then
                print("lol")
            end
        end
    end
end
```

... but it's not always necessary:

```lua
if a and b and c and d then
    print("lol")
end
```

---

# Statements (8)

The `while` loop: repeat a block of code as long as a condition is true

```lua
while condition do
    -- statements
end
```

Example: print numbers from 1 to 10:

```lua
i = 1
while i <= 10 do
    print(i)
    i = i + 1
end
```

Beware the infinite loop:

```lua
while true do
    print("OMG It's a trap!")
end
```

---

# Statements (9)

Loops is what gives a language its computational power to solve *any* problem in existence! Also make them lose the certitude that they will terminate.

> You are now a programmer!

Technically, this is enough. Practically, we'll enjoy some shortcuts.

---

# Bonus statements

The `repeat until` loop: sometimes practical to avoid writing statements twice, or if it is easier to formulate an end condition than a while condition:

```lua
repeat
    -- statements
until endCondition
```

Equivalent to:

```lua
-- statements
while not endCondition
    -- statements
end
```

Note: the statements are always executed at least once.

---

# Bonus statements (2)

For instance, same problem as before:

```lua
i = 1
repeat
    print(i)
    i = i + 1
until i > 10
```

---

# Bonus statements (3)

Numeric `for` loop: many loops will increment an number and exit when reaching a value.

```lua
for variable = startValue, endValue do
    -- statements
end
```

Is (almost) equivalent to:

```lua
variable = startValue
while variable <= endValue do
    -- statements
    variable = variable + 1
end
```

---

# Bonus statements (4)

Still the same example:

```lua
for i = 1,10 do
    print(i)
end
```

Can also specify a step, and go backwards:

```lua
-- even numbers
for i = 0,10,2 do
    print(i)
end

-- odd numbers downwards
for i = 9,1,-2 do
    print(i)
end
```

---

# Bonus statements (5)

> Abort, abort!!

The `break` statement: exits a loop (`while`, `repeat` or `for`) early:

```lua
for i = 1,10000 do
    -- some computation
    if foundSolution then
        break   -- this will bring us...
    end
end
-- ... here!
```

--- 

# Bonus statements (6)

Note: `break` always breaks the innermost loop:

```lua
while something do
    while otherThing do
        if someReason do
            break   -- this will bring us...
        end
    end
    -- ... here!
end
```