class: middle center

# Lua 102

## Did you ask for more awesome?

---

# Contents

- functions
- details about functions
- scope
- standard library
- arrays
- bonus: recursive functions

---

class: middle

# Functions

---

# Functions

A *function* is a named block of code, which can be executed from somewhere else in the program. A function can have *parameters* (inputs) and *return values* (outputs).

Functions are useful for:

- code organisation (separate various problems into distinct pieces of code)
- code reuse (write once, use many times)
- abstraction (solve a problem for a generic input)

---

# A simple function

To *define* a function, we use the keyword `function`:

```lua
-- definition

function printHello()
    print("Hello!")
end
```

Defining the function doesn't execute the code, it only gives it a name.

To *call* a function, we use the function name, followed by `()`:

```lua
-- call

printHello()
print("We did it!")
```

When calling a function, control moves inside the function, executes all its instructions, then comes back to where it was called and continues with the next instruction.

---

# Functions: syntax

Definition:

```lua
function name()
    -- block
end
```

Call:

```lua
name()
```

**Reminder:** defining the function doesn't execute it, it saves it for later use. Calling the function is when it is executed.

**Note:** function names: same rules as variable names (letters, numbers, underscores, cannot start with a number).

---

# Function body

The block inside a function can be any number of instructions, including `if`s, loops, assignments, `print()`, etc.

```lua
function printHello5Times()
    print('Let's print "Hello" five times:')
    for i = 1,5 do
        print("Hello")
    end
    print("Done!")
end
```

---

# Calling functions

Calling a function is an instruction like any other, it can be done anywhere (in any block of code):

```lua
printHello5Times()

for i = 1,10 do
    printHello5Times()
end

if 10 < 100 then
    printHello5Times()
end
```

---

# Mini exercise: functions

- Define a function that outputs your name 10 times. Then call this function a few times.
- Define a function that prints "Foo", and a function that prints "Bar". Then complete the program so that it outputs:
    
        Foo
        Foo
        Bar

    10 times.
- 

---

# Calling other functions

Like any other instructions, functions can call other functions:

```lua
function foo()
    print("Foo")
end

function bar()
    print("Bar")
    foo()
end

bar()   -- ouputs: Bar  Foo
```

---

# Side effects

Function can also modify variables, and output stuff. In general, anything that modifies memory or peripherals is called a *side effect*:

```lua
function foo()
    a = 5
    print("I did it!")
end

print(a)    -- nil
foo()       -- I did it!
print(a)    -- 5
```

---

# Mini exercice: side effect

Write a function `increment()` that increases the value of variable `a` by 1, so that the following program:

```lua
-- your code here

a = 10
increment()
increment()
print(a)
```

would output 12.

---

# Function parameter

A function can be defined to have a *parameter* (input). When we call that function, we will *pass* a value, that the function can use for computations or other stuff:

```lua
-- definition

function printThisNumber(number)
    print("You asked me to print: " .. number)
end

-- call

printThisNumber(5)
```

When we call `printThisNumber(5)`, not only control passes to the function, but also the value 5 is assigned to the variable `number` inside the function.

---

# Parameter: syntax

Definition:

```lua
function name(parameterName)
    -- block
end
```

The parameter name follows the same rule as variable (it *is* in fact a variable).

Call:

```lua
name(expression)
```

In the call, we put an expression inside the parentheses:

- a literal: `-3.5 "Hello" true`...
- a variable
- an operation: `3 + 5`

---

# Parameter

Parameters can be of any type:

```lua
function printThisTwice(s)    
    print(s)
    print(s)
end

printThisTwice("Bob")
printThisTwice(200)
```

But remember that some operations work only with certain types:

```lua
function printDouble(n)
    print(n * 2)
end

printDouble(5)      -- 10
printDouble("Foo")  -- ERROR!!
```

---

# Mini exercices: parameter

Write a function that:

- prints whether the parameter is a positive number (bigger than 0) or not
- prints "Hello world" `N` times, where `N` is the function parameter
- prints the 10 first multiples of the parameter `N` (eg. given 3, it would print 3, 6, 9, 12, etc.)
- prints whether the parameter is a multiple of 7

---

# Multiple parameters

A function can be defined to have multiple parameters (separated with commas: `,`)

```lua
function multiply(a, b)
    print(a * b)
end
```

A function with multiple parameters is called by passing multiple values (comma separated expressions)

```lua
multiply(10, 4)

a = 129
multiply(a, 8 + 1)
```

When calling the function, all the values passed are assigned to the parameters (in the same order) inside the function, which can use them for whatever.

---

# Mini exercices: multiple parameters

Write a function that:

- takes 2 parameters, and prints each on one line
- takes 2 parameters (strings or numbers), and prints them both on one line
- takes one string `s` and one number `N`, and prints the string `s`, `N` times
- takes three numbers, and prints their sum

---

# Return value

A function can have a *return value* (output): a result that is *returned* to the caller. We use the keyword `return`, followed by an expression:

```lua
function double(n)
    return n * 2
end
```

When a function has a return value, the function call is itself an expression, that can be used in `print()`, operations, assigned to variables, etc.

```lua
print(double(10))

a = double(12)
print(a)

print(double(12) + 5)
```

---

# Return instruction

The `return` instruction can be at the end of any block inside the function. Mostly useful once you have the result of a computation:

```lua
function weird(n)
    if n % 2 == 0 then
        return n + 1
    else
        return n * 3
    end
end

function solve(n)
    for i = 1,n do
        -- some computation
        if foundSolution then
            return solution
        end
    end
end
```

When encountering `return`, control will return *immediately* to the caller.

---

# Return type

You can return any value you want, and the type of the return value becomes the type of the function call expression:

```lua
function concatFoo(s)
    return s .. "Foo"
end

print(concatFoo("Hi"))              -- HiFoo
print(concatFoo("Hi") .. "Bar")     -- HiFooBar
```

Here, the call `concatFoo("Hi")` is an expression of type string and can be used anywhere a string can be used.

---

# Mini exercises: returning values

Write a function that:

- takes two numbers A and B, and returns A × A + B × B
- takes a string `s`, a number `N`, and returns `s` concatenated to itself `N` times (for instance passing "Ben" and 3 would return "BenBenBen")
- takes a number `N`, and returns true is `N` is even, or false if `N` is odd

---

class: middle

# Details about functions

---

# Mixing side effects

You can use side effects and return values in the same functions:

```lua
function multiply(a,b)
    print("Let's multiply " .. a .. " and " .. b)
    return a * b
end

result = multiply(3,6)
print(result)
```

---

# Ignoring the return value

If a function returns a value, but you don't use it (assign it to a variable, or print it, etc.), it is discarded. The function is still executed (side effects will happen).

```lua
function foo(n)
    print("This is foo " .. n)
    return n * n + 2
end

foo(3)  -- outputs: This is foo 3
```

Here, the return value (11) is computed, but discarded immediately.

---

# Forgetting the return value

Conversely, trying to save the return value of a function that doesn't return anything will result in `nil`:

```lua
function doSomething()
    print("Doing something")
end

print(doSomething())
a = doSomething()
print(a)
```

We say that the function doesn't return anything, or "returns nil".

---

# Forgetting the return value

A more likely scenario:

```lua
function half(n)
    if n % 2 == 0 then
        return n / 2
    end
end

print(half(10))     -- 5
print(half(11))     -- nil
```

It can happen:

- when you forgot one possible case
- on purpose: `nil` can mean "no result"

---

# Returning nil

You can also force the function to return immediately using `return` alone.

```lua
function blah()
    for i = 1,1000 do
        -- something
        if someReason then
            return
        end
    end
end
```

**Note:** it will return nil. In fact you can even explicitly write `return nil`. Same thing.

---

# A well known function

```lua
print(5)
print("Hello")
```

`print()` is a built-in function: it takes arguments of any type, and outputs them to the console.

It has only side effects though (it doesn't return anything):

```lua
a = print("Hi")     -- Hi
print(a)            -- nil
```

In fact, it can take multiple arguments (prints them on one line, separated with tabs):

```lua
print(1, "Hello", true)     -- 1    Hello   true
```

Convenient for quick output where you don't care about formatting.

---

# Lua's standard library

Complete documentation in the [reference](http://www.lua.org/manual/5.1/) (we'll see later what the dot in the function names means).

```lua
-- absolute value
print(math.abs(-4))         -- 4

-- pi (a variable, not a function)
print(math.pi)              -- 3.141592

-- cosine and sine
print(math.cos(math.pi))    -- -1
print(math.sin(0))          -- 0

-- square root
print(math.sqrt(81))        -- 9

-- min and max
print(math.max(4,19,11))    -- 19
print(math.min(4,19,11))    -- 4

-- random numbers
print(math.random())        -- eg. 0.0012512588885159
```

---

# Lua's standard library (2)

Error function:

```lua
if somethingWrong then
    error("AARGH??")          -- panic: exit program
end
```

OS:

```lua
print(os.clock())  -- seconds since the start of the program
print(os.time())   -- seconds since 1 January 1970 00:00 UTC
print(os.date())   -- the current date as a string
os.exit()          -- immediately exit program
```

---

class: middle

# Scope

---

# Lexical scoping

> *Scope*: the region of program source in which an identifier is meaningful.

*Scoping* is the fact that variables can be visible or not to other parts of the program, depending on where they are defined.

*Lexical* scoping means that these visibility rules depend only of the source code, and not of the state of the program at execution (the standard in most languages, much easier to visualize, understand, and maintain).

In Lua: exactly two scopes: *local* and *global*.

---

# Global variables

The ones we have used so far:

- no need to declare (just use them)
- visible from *everywhere*: can read them and write them in any block of code

```lua
function setIt()
    a = 5
end

function printIt()
    print(a)
end

printIt()       -- nil
setIt()
print(a)        -- 5
printIt()       -- 5
a = 10
printIt()       -- 10
```

---

# Local variables

- must be declared using `local` keyword
- exist *only* in the block of code they were declared in

```lua
a = 6

if a > 3 then
    local double = a * 2
    print(double)           -- 12

    -- double goes "out of scope"
end

print(double)   -- nil, because trying to access a global
```

---

# Declaring a local

No need to initialize immediately:

```lua
local zob       -- declared, still nil
if something then
    zob = 5
else
    zob = 10
end

print(zob)
```

---

# Shadowing

Local variables *shadow* variables of outer scopes:

```lua
a = 10
local b = 11

if 10 < 100 then
    local a = 100
    local b = 200
    print(a,b)      -- 100    200

    -- locals a and b go out of scope
end

print(a,b)      -- 10    11
```

---

# Implicit locals

We've been using locals already!

Implicitely declared local variables:

- iterator in `for` loops
- parameters in functions

```lua
i = 50
for i = 1,10 do
    print(i)    -- 1, 2, 3...
end
print(i)        -- 50

function printTwice(i)
    print(i)
    print(i)
end

printTwice("lol")   -- lol, lol
print(i)            -- 50
```

---

# Blocks and scopes

Every new block of code opens a new scope:

- `then`, `elseif` and `else` blocks in `if` statement
- the body of `for` loops
- the body of a function
- a Lua chunck (because it's actually a function)

```lua
local foo = 5
for i = 1,10 do
    local foo = i * 2
    print(foo)
    if i < 5 then
        local foo = "Smaller"
        print(foo)
    else
        local foo = "Bigger"
        print(foo)
    end
end
print(foo)
```

**Note:** one more reason to indent your code correctly: a visual reminder of the blocks, and therefore, of the scopes of your variables.

---

# Locals: tips

- Always use locals inside a function. Have functions act on their arguments instead of globals.
    - cleaner code: input -> output, no side effects which are more difficult to track
    - more independent logical unit

```lua
-- compare:
doSomething()   -- what did you do, did you change anything?

-- to:
output = treatData(input)   -- that's quite clear
```

- Small, temporary results should be locals too: use them freely, throw them away.
- In fact, very few cases where globals are necessary, or useful.
- As programs grow, everything will be functions, so all variables will be locals.

---

# Exercises: locals

Rewrite these previous exercises using functions and *only* local variables:

- write a function that checks if a number `N` is prime (it should return a boolean), then:
    - print all primes under 1000
    - print the first prime bigger than one million
    - print the 2000th prime number
- write a function that returns the `N`-th Fibonacci number

Don't hesitate to:

- experiment with global and local variables
- make sure you understand the scoping rules

In the future:

- think "one problem, one function"
- break down problems in smaller problems: functions that call other functions
- use locals!
- avoid globals!

---

class: middle

# Arrays

---

# Arrays

The first non-basic type in Lua: a *collection* of values identified by a numerical *index*, stored contiguously in memory.

Created using an array literal:

```lua
foo = {}    -- create empty array, stores it in foo
bar = {"lol", 5, true, 2}   -- create array with 4 elements
```

Values are stored and retrieved using integer indices and the square brackets syntax:

```lua
bar = {"a", "b", "c", "d"}
print(bar[2])   -- b
bar[3] = "lol"
print(bar[3])   -- lol
```

Indices start at 1.

---

# Array indexing

Can use any expression as index, as long as it is an integer (that's a lie):

```lua
index = 3
foo = {11, 12, 13}
print(foo[1 + 1], foo[index])   -- 12    13
```

Trying to access an element that is not set returns `nil`:

```lua
array = {"hiii"}
print(array[1000])  -- nil
```

---

# Array indexing (2)

Do not have to set elements contiguously (the array can have gaps):

```lua
array = {}
array[100] = "foo"
for i = 1,100 do
    print(array[i]) -- nil, nil, nil... foo
end
```

In that sense, the Lua array sort of has infinite size, but all its elements start as `nil`.

---

# Array length operator

When an array does not have gaps, the unary `#` operator returns its length:

```lua
array = {"foo", "bar", 1, true}
print(#array)   -- 4
array[4] = nil
print(#array)   -- 3
```

If some elements are `nil`, it may or may not work (will return the index of *any* non `nil` element followed by `nil`):

```lua
array = {1, nil, 2, 3, 4, nil, 5}
print(#array)       -- could be 1, 5 or 7
```

If needed, the function `table.maxn` will return the index of the highest non `nil` element of an array.

Rule of thumb: unless you have a good reason to, don't put `nil` in the middle of an array.

---

# Array length operator (2)

Common idioms:

```lua
-- iterate over all elements of array
for i = 1,#array do
    -- set or get array[i]
end

-- add element at the end of array
array[#array + 1] = "foo"

-- remove last element of array
array[#array] = nil

-- print array contents with separator
print(table.concat(array, ","))
```

---

# Array operations

Insert element in array (pushing all following elements up):

```lua
array = {1,2,3,4,5,6,7,8,9,10}
table.insert(array, 5, "lol")
print(table.concat(array, ","))     -- 1,2,3,4,lol,5,6,7,8,9,10

-- with no argument: add at the end
table.insert(array, "bar")
print(table.concat(array, ","))     -- 1,2,3,4,lol,5,6,7,8,9,10,bar
```

Remove element in array (pushing all following elements down):

```lua
array = {1,2,3,4,5,6,7,8,9,10}
table.remove(array, 5)
print(table.concat(array, ","))     -- 1,2,3,4,6,7,8,9,10

-- with no argument: remove from the end
table.remove(array)
print(table.concat(array, ","))     -- 1,2,3,4,6,7,8,9
```

---

# Array operations (2)

Adding/removing elements at the *end* of the array is efficient. Doing it somewhere else may result in up to `#array` operations internally (the pushing up/down of elements)

Mini exercice: write functions `table.insert` and `table.remove` yourself, to understand why.

---

# Reference type

All basic types (number, string, boolean, nil) are *value* types: the variable *contains* the value. Assignment copies it:

```lua
a = 5
b = a
a = 6
print(a,b)  -- 6    5
```

The array is a *reference* type. When creating an array, some memory is allocated "somewhere", and a *reference* to it is returned. A variable can only contain the reference to the array, not the array itself. Several variables can hold a reference to the same array:

```lua
a = {"foo"}
b = a
print(a[1], b[1])     -- foo    foo
a[1] = "bar"
print(a[1], b[1])     -- bar    bar
```

---

# Reference type (2)

When an array reference is erased or replaced, it doesn't affect the array itself:

```lua
a = {"foo"}
b = a
a = {"bar"}
print(a[1], b[1])   -- bar    foo
```

An array is deleted only if *all* the references to it are lost:

```lua
a = {"foo"}
b = a
a = nil
print(b[1])     -- foo
b = nil
-- can't access it anymore!
```

The *garbage collection* takes care of freeing the memory.

---

# Reference type (3)

Passing "an array" (ie. a reference to an array) to a function allows the function to modify it:

```lua
function foo(array)
    array[1] = "foo"
end

a = {"a", "b", "c"}
foo(a)
print(table.concat(a, ",")) -- foo,b,c
```

To actually copy the contents of an array:

```lua
dest = {}
for i = 1,#source do
    dest[i] = source[i]
end
```

---

# Reference type (4)

By abuse of language:

- assign an array (assign a reference to an array)
- the variable contains an array (refers to an array)
- pass an array to a function (pass a reference to an array)
- variable of array type (variable of array reference type)
- ...

It's ok to take shortcuts as long as the semantics are clear! In Lua, *all* arrays are by-reference, unlike some other languages.

---

# Exercices

- write a function `fib(n)` that returns an array containing the `n` first Fibonacci numbers
- write a function `min(arr)` that returns the index and value of the smallest element of array `arr` (assume `arr` contains numbers)
- write a function that prints all pairs of elements of an array (for instance, passing `{"a",1,true}` would print `(a,1)(a,true)(1,true)`)
- write a function that removes all duplicate elements from an array
- write a function that, given an array of integers, splits the elements into two arrays: the primes and the non-primes
- write a function that given a integer, returns an array containing its digits (for instance, passing 2098 would return `{2,0,9,8}`)
- write a function that, given a integer up to 999'999'999, returns its spelling in Finnish (passing 7654 would return the string "seitsemäntuhattakuusisataaviisikymmentäneljä")

---

# Recursive functions

- A function can call itself.
- Lua (and most languages) is *reentrant*: each invocation of a function creates a new copy of its local variables

Note: a function that uses global variable is not reentrant

Recursion is useful when solving a problem consists in:

- solving the same problem for smaller data set(s)
- use/combine the sub-result(s) for the bigger problem

---

# Recursive functions (2)

For instance: counting down from `n` is saying `"n"` and counting down from `n-1`.

```lua
function countdown(n)
    print(n)
    countdown(n-1)
end

countdown(10)   -- 10, 9, 8, ..., 2, 1, 0, -1, -2, -3...
```

Then:

`error: stack overflow`

There is a limit to how many recursive calls you can make (~16000+)

---

# Recursive functions (3)

Don't forget the recursion *base*:

```lua
function countdown(n)
    print(n)

    if n <= 0 then
        return
    end

    countdown(n-1)
end

countdown(10)   -- 10, 9, 8, ..., 2, 1, 0
```

Note: some problems are better solved iteratively. All recursive functions can be "unfolded" into an iterative flow. But sometimes, recursion is much more elegant.

---

# Exercices/examples

- write recursive function `fact(n)` that computes the factorial of integer `n`
- write recursive function `fib(n)` that computes the `n`-th Fibonacci number
- write recursive function `palin(s)` that checks if string `s` is a palindrome

---

# Recursive factorial

```lua
function fact(n)
    if n <= 1 then
        return 1
    else
        return n * fact(n-1)
    end
end
```

---

# Recursive Fibonacci

```lua
function fib(n)
    if n <= 2 then
        return 1
    else
        return fib(n-2) + fib(n-1)
    end
end
```

---

# Recursive palindrome

```lua
function palin(s)
    if #s <= 1 then
        return true
    end

    return string.sub(s,1,1) ==
        string.sub(s, #s, #s) and
        palin(string.sub(s, 2, #s-1))
end
```

---

# A real recursivity exercice

Solve the [tower of Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi) problem.

- 3 pegs
- N discs: always a smaller disc on top of a larger disc
- goal: move all N discs from the first peg to the third

![Hanoi](https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg)

Hint: notice that moving N discs from peg A to peg B consists in moving N-1 discs from A to C, moving the N-th disc from A to B, and then N-1 discs from C to B.

---

# Homework

To prepare for next lesson (algorithmics): write a function `sort(arr)` that, given an array of numbers, returns an array containing the same numbers, but sorted in increasing order.

```lua
result = sort({3,20,500,8,3,45,91,31,23})
print(table.concat(result, ","))

-- should output: 3,3,8,20,23,31,45,91,500
```

- there are many, many ways
- if stuck, get a shuffled pack of cards, sort them by hand and try to break down your algorithm into its essential parts
- if you find several solutions, try to compare their efficiency: how many operations happen in each, for an array of size N (comparisons, copies, swaps, etc.)