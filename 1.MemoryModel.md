class: center middle

# The memory model

## What is a computer?

---

Von Neumann architecture
========================

- processor
- random access memory (RAM)
- peripherals

Program: sequence of machine code instructions encoded in binary

---

Von Neumann architecture (2)
========================

To execute ("run") a program:

- copy entire program somewhere in memory
- point processor at first instruction ("start here")
- processor reads instruction
- processor executes instruction
- processor goes to next instruction
- go on forever

Which means:

- Program and data are in the *same* memory!
- Program *is* data!
- Confusing!
- Irrelevant for this course!

---

Operating system
================

Operating system (itself a program!) takes care of:

- loading programs from hard drive to memory
- cleaning up memory when program is over
- running several programs at the same time
- providing libraries for easier access to hardware

---

Program and data
================

Instructions in a program are mostly about:

- manipulate data
	- read data from memory/peripherals
	- write data to memory/peripherals
	- perform simple operations on data
		- arithmetics
		- comparison
- jumping to other instructions depending on some data ("if this, then jump"). Otherwise a program would always do the exact same thing, boring.
- that's pretty much it!

You can now write Mass Effect 3!

---

What's data anyway?
===================

Memory is just a big bunch of boxes. Each box:

- can contain a number from 0 to 255. That's a *byte*.
- has an *address*, from 0 to however many bytes of RAM your computer has.

When the processor deals with memory, it looks like this:

- write result of previous operation to some address
- read number from some address, and use it for next operation

---

What's data anyway? (2)
===================

Anything we want a computer to deal with has to be encoded somehow with bytes. That's the law.

In practice, the laws of electronics are such that it's easier to have boxes of zeros and ones than boxes of anything from 0 to 255. That's *bits*. A byte is made of 8 bits. But since the processor cannot address individual bits (only bytes), it doesn't really matter.

---

Other kinds ("types") of data
=============================

So, integers from 0 to 255 are not enough?

- take two bytes at a time for integers from 0 to 65535
- 4 bytes: 0 to 4294967295
- 8 bytes: 0 to 18446744073709551615

Fortunately, the processor can also read, write and operate directly on integers of these sizes.

- Negative integers? Just interpret the first bit a being the sign, and the rest as a positive integer (that's a lie).
- Non integer numbers? Use part of the bits for the integer part, and the rest for the fractional part (that's also a lie).

---

Other kinds ("types") of data (2)
=============================

- Text? Use a one to one match between characters and numbers (an *encoding*) and interpret numbers as characters. In ASCII, 'a' is 97, 'W' is 87 and '$' is 36.
- How about colors for the pixels on the screen? One number from 0 to 255 for the red component, another for the blue component, another for the green. Three bytes make a pixel.
- Sound? The CD format specifies 2 byte integers for each samples, and 44100 samples per second.

> It's all numbers!
