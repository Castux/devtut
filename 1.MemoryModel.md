class: center middle

# The memory model

## What is a computer?

---

Von Neumann architecture
========================

- processor
- random access memory (RAM)
- peripherals

Program: sequence of machine code instructions encoded in binary

![Von Neumann](http://www-history.mcs.st-and.ac.uk/BigPictures/Von_Neumann_5.jpeg)

---

Von Neumann architecture (2)
========================

To execute ("run") a program:

- copy entire program somewhere in memory
- point processor at first instruction ("start here")
- processor reads instruction
- processor executes instruction
- processor goes to next instruction
- go on forever

Which means:

- Program and data are in the *same* memory!
- Program *is* data!
- Confusing!
- Irrelevant for this course!

---

Operating system
================

Operating system (itself a program!) takes care of:

- loading programs from hard drive to memory
- cleaning up memory when program is over
- running several programs at the same time
- providing libraries for easier access to hardware

![OSes](http://statfaking1.firstpost.in/wp-content/uploads/2014/02/operating-system-logos.jpg)

---

Program and data
================

Instructions in a program are mostly about:

- manipulate data
	- read data from memory/peripherals
	- write data to memory/peripherals
	- perform simple operations on data
		- arithmetics
		- comparison
- jumping to other instructions depending on some data ("if this, then jump"). Otherwise a program would always do the exact same thing, boring.
- that's pretty much it!

You can now write Mass Effect 3!

![ME](http://wallofscribbles.com/wp-content/uploads/2012/11/Mass-Effect-3-Fem-Shep.jpg)

---

What's data anyway?
===================

Memory is just a big bunch of boxes. Each box:

- can contain a number from 0 to 255. That's a *byte*.
- has an *address*, from 0 to however many bytes of RAM your computer has.

When the processor deals with memory, it looks like this:

- write result of previous operation to some address
- read number from some address, and use it for next operation

---

What's data anyway? (2)
===================

Anything we want a computer to deal with has to be encoded somehow with bytes. That's the law.

In practice, the laws of electronics are such that it's easier to have boxes of zeros and ones than boxes of anything from 0 to 255. That's *bits*. A byte is made of 8 bits. But since the processor cannot address individual bits (only bytes), it doesn't really matter.

---

Other kinds ("types") of data
=============================

So, integers from 0 to 255 are not enough?

- take two bytes at a time for integers from 0 to 65535
- 4 bytes: 0 to 4294967295
- 8 bytes: 0 to 18446744073709551615

Fortunately, the processor can also read, write and operate directly on integers of these sizes.

- Negative integers? Just interpret the first bit a being the sign, and the rest as a positive integer (that's a lie).
- Non integer numbers? Use part of the bits for the integer part, and the rest for the fractional part (that's also a lie).

---

Other kinds ("types") of data (2)
=============================

- Text? Use a one to one match between characters and numbers (an *encoding*) and interpret numbers as characters. In ASCII, 'a' is 97, 'W' is 87 and '$' is 36.
- How about colors for the pixels on the screen? One number from 0 to 255 for the red component, another for the blue component, another for the green. Three bytes make a pixel.
- Sound? The CD format specifies 2 byte integers for each samples, and 44100 samples per second.

> It's all numbers!

---

class: center middle

# Appendix

---

# Binary numbers

Base 2 positional numeral system. Just like "ordinary" numbers are base 10.

```
25486  = 2 * 10^4 +  5 * 10^3 + 4 * 10^2 + 8 * 10^1 + 6 * 10^0
       = 2 * 10000 + 5 * 1000 + 4 * 100  + 8 * 10   + 6 * 1


10110b = 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0
       = 1 * 16  + 0 * 8   + 1 * 4   + 1 * 2   + 0 * 1
       = 22
```

Arithmetics work the same:

```
   1101 (13)              1101 (13)
+  1001 (9)           x     11 (3)
-------               --------
= 10110 (22)              1101 (13)
                         1101  (26)
                      --------
                      = 100111 (39)
```

---

# Binary numbers (2)

- bit: **b**inary dig**it** (0 to 1)
- octet: 8 bits (0 to 255)
- byte: smallest addressable amount of memory (= 1 octet on most modern CPU architectures)
- nybble: half a byte, 4 bits (0 to 15)
- word: the "normal" integer size for the architecture (was 16 bits, now 32 or 64)

---

# Hexadecimal numbers

Same positional numeral system, but base 16.

- hex digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f
- 1 hex digit = 1 nybble (0x0 to 0xf)
- 2 hex digits = 1 byte (0x0 to 0xff)

```
0xdeadbeef = 3735928559
```

---

# Negative numbers

2's complement: invert all bits, add one (ignoring overflow)

```
5 = 0000 0101  ==>  -5 = 1111 1010 + 1 = 1111 1011
```

Why? Does not change the addition operation:

```
  0000 0101 (5)            0001 0101 (21) 
+ 1111 1011 (-5)         + 1111 0111 (-9)
-----------              -----------     
  0000 0000 (0)            0000 1100 (12)


  0001 1001 (25)   
+ 1001 1100 (-100)  
-----------       
  1011 0101 (-75)   
```
