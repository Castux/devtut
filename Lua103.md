class: middle center

# Lua 103

## Awesomeness never stops!

---

# Contents

- logical operators
- tables
- string manipulation

---

class: middle

# Logical operators

> Logic will get you from A to B. Imagination will take you everywhere. (Albert Einstein)

---

# Exercise: and

Write a function `logical_and()` that, given too boolean arguments, returns true if both arguments are true (and false otherwise):

```lua
function logical_and(a,b)
    -- your code here
end

print(logical_and(false, false))  -- false
print(logical_and(false, true))   -- false
print(logical_and(true, false))   -- false
print(logical_and(true, true))    -- true
```

---

# Solution: and

```lua
function logical_and(a,b)
    if a then
        if b then
            return true
        end
    end
    return false
end
```

or shorter:

```lua
function logical_and(a,b)
    if a then
        return b
    else
        return false
    end
end
```

---

# Exercise: or

Write a function `logical_or()` that, given too boolean arguments, returns true if at least one argument is true (and false otherwise):

```lua
function logical_or(a,b)
    -- your code here
end

print(logical_or(false, false))  -- false
print(logical_or(false, true))   -- true
print(logical_or(true, false))   -- true
print(logical_or(true, true))    -- true
```

---

# Solution: or

```lua
function logical_or(a,b)
    if a then
        return true
    elseif b then
        return true
    end

    return false
end
```

Or shorter:

```lua
function logical_or(a,b)
    if a then
        return true
    else
        return b
    end
end
```

---

# Exercise: not

Write a function `logical_not()` that, given true, returns false, and vice versa:

```lua
function logical_not(a)
    -- your code here
end

print(logical_not(true))   -- false
print(logical_not(false))  -- true
```

---

# Solution: not

```lua
function logical_not(a)
    if a then
        return false
    else
        return true
    end
end
```

Or shorter:

```lua
function logical_not(a)
    return a ~= true
end
```

---

# Logical operators: `and`, `or`, `not`

These three logical operations exist as the operators `and`, `or`, and `not`:

```lua
print(false and false)  -- false
print(false and true)   -- false
print(true and false)   -- false
print(true and true)    -- true

print(false or false)  -- false
print(false or true)   -- true
print(true or false)   -- true
print(true or true)    -- true

print(not false)       -- true
print(not true)        -- false
```

In (mathematical) logic:

- "A and B" means "both A and B are true"
- "A or B" means "either A or B (or both) are true"
- "not A" means "A is not true"

---

# Control flow logic

These operators take booleans, and form boolean expressions. As such, they can be used as conditions in `if`, and `while`:

```lua
N = 50
if N % 2 == 0 and N > 100 then
    print(N .. " is odd, and bigger than 100!")
end
```

They can use variables:

```lua
N = 100
isOdd = N % 2 == 0
isBig = N > 50

if isOdd and isBig then
    print(N .. " is odd, and bigger than 100!")
end
```

---

# Saving booleans

...and their results can be saved in variables:

```lua
isRaining = true
haveUmbrella = false

willGoForAWalk = (isRaining and haveUmbrella) or not isRaining
```

Like other operations, they can be chained as much as you want:

```lua
if a and b and c and d then
    print("a, b, c and d are all true!")
end

if a or b or c or d then
    print("At least one of a, b, c or d is true!")
end
```

---

# Mini exercise: logical operators

Complete the following program so that it prints all elements of the array that:

- start or end with the letter "a"
- contain more than 5 letters and can be cut in three equal parts

```lua
words = {"avocado", "burrito", "enchilada",
	"guacamole", "tequila", "mojito", "ola"}

-- your code here
```

---

class: middle

# Tables

> A single conversation across the table with a wise man is better than ten years of study. (Chinese proverb)

---

# Tables

Arrays are a special case of a more general type: the table. A table associates *keys* with *values*. Syntax to set or get elements of a table is the same as arrays (because arrays *are* tables): `name[key]`

```lua
age = {}      -- create empty table
age["Alice"] = 10
age["Bob"] = 5
age["Charlie"] = 22
```

| Key     | Value |
|---------|-------|
| Alice   | 10    |
| Bob     | 5     |
| Charlie | 22    |

---

# Types in tables

Can mix types as much as wanted:

```lua
t = {}
t["Hello"] = 10
t[2.5] = true
t[false] = "Whatever"
```

| Key     | Value      |
|---------|------------|
| "Hello" | 10         |
| 2.5     | true       |
| false   | "Whatever" |

**Note**: the only thing you cannot do is use nil as a key.

---

# Retrieving from tables

To get an element, same syntax as arrays: `table[key]`:

```lua
t = {}
t["Hello"] = 10
t[2.5] = true
t[false] = "Whatever"
t["Foo"] = "Bar"

print(t["Hello"])
print(t[2.5])
print(t[false])
print(t["Foo"])
```

---

# Keys

Just like indices in arrays, the key can be any expression (including using a variable or an operation):

```lua
t = {}
key = "Foo"
t[key] = 23
t[key .. key] = -2.4

print(t[key])       -- 23
print(t["FooFoo"])  -- -2.4
```

Just like in arrays, trying to access an element which is not in the table will return nil:

```lua
t = {}
print(t["Blah"])    -- nil
```

---

# Erasing elements

...and erasing an element from the table can be done by assigning nil:

```lua
t = {}
t[3.5] = false
print(t[3.5])   -- false
t[3.5] = nil
print(t[3.5])   -- nil
```

And checking the presence of a key/value pair is checking that the value is non nil:

```lua
if t[key] ~= nil then
    print("There is a value for key " .. key)
end
```

---

# Table recap

Not much is new! Works the same as arrays, except that the index (or "key") can be of any type. Arrays are simply tables were all keys are positive integers.

**Reminder**: when all keys are consecutive positive integers, we have "special" things that we can do with the table:

- use the length operator `#`
- use `table.insert()` and `table.remove()`
- use `table.concat()`

But really, we've been using tables all along!

---

# Mini exercises: tables

- Using a table, write a program that greets a user according to their name. If it's Alice, say "Hello Alice", if it's Bob, say "Oh hi, Bob!", and if it's Charlie, say "Charlie, so nice to see you!". If it's someone else, just say "Welcome".

- Fill a table `age` with the following information, and write a function that prints results such as "You are Alice, you are 22 years old.", or an error message if the person is unknown:

| Key     | Value |
|---------|-------|
| Alice   | 22    |
| Bob     | 5     |
| Charlie | 65    |
| Dorothy | 34    |
| Emily   | 50    |

---

# Table literal

Syntax to create a table directly with key/value pairs: `{[key] = value, [key] = value, ...}`

```lua
t =
{
    ["Alice"] = 3,
    [true] = 2.4,
    [-4] = 3
}

print(t[true])  -- 2.4
```

Here too, keys and values can be any expression (as long as keys don't evaluate to nil).

---

# Reference type

Like the array before, tables are a *reference type*: variables do not contain the table, only a reference to it. Several variables can refer to the same table, etc.

```lua
a = { ["Foo"] = "Bar" }
b = a
print(a["Foo"], b["Foo"])   -- Bar  Bar
a["Foo"] = 245
print(b["Foo"])     -- 245
```

It's exactly the same as arrays, because arrays *are* tables.

---

# Generic `for` and `pairs()`

To iterate over all the key/value pairs in a table: the generic `for` loop:

```lua
t = {}
t["Hello"] = 10
t[2.5] = true
t[false] = "Whatever"
t["Foo"] = "Bar"

for key,value in pairs(t) do
    print(key, value)
end
```

Output:

```
Hello   10
false   Whatever
2.5 true
Foo Bar
```

---

# Generic `for` syntax

```lua
for key,value in pairs(table) do
    -- use key and value
end
```

- `key` and `value` are variable names (often `k,v`), `table` is an expression of type table.
- there is no order in a table. Using `for` and `pairs()` will not necessarily iterate in the same order that the values were added to the table.
- the variables `key` and `value` are local to the body of the loop. They will shadow any outer variable with the same names, and they stop existing after the loop exits.
- like any loop, you can use `break` to exit immediately

---

# Mini exercise: generic `for` loop

- using the same age table as before, write a program that outputs sentences such as "Hello Alice, you are 22 years old!" for all persons in the table
- write a function that takes a table and another argument `k`, and returns true if `k` is in the table *as a key*
- write a function that takes a table and another argument `v`, and returns true if `v` is in the table *as a value*
- write a function that takes a table and returns the number of key/value pairs in it

---

# Arrays are tables!

**Reminder**: arrays *are* tables. We just restricted the keys to positive integers:

```lua
array = {"a", "b", "c", "d", "e"}

-- is exactly the same as
array =
{
    [1] = "a",
    [2] = "b",
    [3] = "c",
    [4] = "d",
    [5] = "e"
}

-- which is the same as
array = {}
array[1] = "a"
array[2] = "b"
array[3] = "c"
array[4] = "d"
array[5] = "e"
```

---

# Arrays are tables!!!

Since arrays *are* tables, the generic `for` loop works on arrays too:

```lua
array = {"a", "b", "c", "d", "e"}

for k,v in pairs(array) do
    print(k,v)
end
```

Output:

```
1   a
2   b
3   c
4   d
5   e
```

**Reminder:** when using `for` and `pairs`, the order is never guaranteed. The only certain thing is that you will iterate over all the key/value pairs...

---

# Arrays and `pairs()`

... on the other hand, it's convenient for sparse arrays (arrays with gaps):

```lua
a = {}
a[2] = "Two"
a[1000] = "One thousand"

for k,v in pairs(a) do
    print(k,v)
end
```

---

# Arrays and `ipairs()`

For tables that use consecutive positive integers as keys (aka arrays), use the generic `for` loop with `ipairs()` (notice the i for "integer" or "index"):

```lua
array = {"a", "b", "c", "d", "e"}

for index,value in ipairs(array) do
    print(index,value)
end
```

- this one is guaranteed to go over the elements in order
- `index` and `value` are also local variables, often `i,v`
- doesn't play well with gaps (might stop at the first nil it finds)
- basically a shortcut for:

```lua
for index = 1,#array do
    local value = array[index]
    -- block
end
```

---

# Mini exercise: `ipairs()`

Using the generic `for` loop and `ipairs()`:

- write a function that returns true if an element `e` is in an array
- write a function that returns the smallest element of an array of numbers
- write a function that returns the average of all elements of an array of numbers

---

class: middle

# Multiple assignments

> The love of beauty in its multiple forms is the noblest gift of the human cerebrum. (Alexis Carrel)

---

# Multiple assignment

So far we've always done assignment with one variable on the left, and one expression on the right:

```lua
var = 10
```

In Lua, we can assign *multiple* values to *multiple* variables at the same time, by separating them with commas:

```lua
var1, var2, var3 = 10, "Hello", true
print(var1, var2, var3) -- 10  Hello   true
```

---

# Evaluation order

All the expressions on the right are evaluated first, and then the values are assigned to the variables.

Convenient for swapping values:

```lua
a, b = "foo", "bar"
print(a,b)
a, b = b, a
print(a,b)
```

---

# Scope

Writing `local` before the variables will declare all the variables as locals:

```lua
a,b,c = 1,2,3

if true then
    local a,b,c = 10,20,30
    print(a,b,c)    -- 10   20  30
end

print(a,b,c)    -- 1    2   3
```

---

# Multiple return values

Functions can return multiple values too!

```lua
function doubleAndHalf(n)
    return n*2, n/2
end
```

To get all the return values, we put several variables on the left side of the assignment:

```lua
double, half = doubleAndHalf(10)
print(double, half)     -- 20   5
```

If you put N variables on the left, you get only the first N return values. If you put more variables than there are return values, the additional ones get nil:

```lua
double = doubleAndHalf(10)
print(double)       -- 20
a,b,c,d = doubleAndHalf(10)
print(a,b,c,d)      -- 20  5   nil nil
```

---

# Standard library

Some built-in functions return multiple values:

```lua
integral, fractional = math.modf(21.56)
print(integral, fractional)     -- 21    0.56

first, last = string.find("This is cool", "cool")
print(first, last)      -- 9    12
```

---

# Mini exercises: multiple return values

- modify your "smallest element of an array of numbers" function, so that it returns both the smallest number, and the index it was found at
- write a function that returns the first and last elements of an array

---

class: middle

# String manipulation

> There is geometry in the humming of the strings, there is music in the spacing of the spheres. (Pythagoras)

---

# Fun with strings

So far, we know how to:

- get the length of a string: `#s`
- concatenate strings to build bigger strings: `a .. b`
- get the `i`-th character in a string: `string.sub(s, i, i)`

There is a lot more we can do!

---

# Substring

To extract a part of a string (a "SUBstring"): `string.sub(s, i, j)`

> Returns the substring of `s` that starts at `i` and continues until `j`

```lua
s = "Hello, this is dog!"

print(string.sub(s, 1, 5))        -- Hello 
print(string.sub(s, 8, 11))       -- this 

-- the whole thing!
print(string.sub(s, 1, #s) == s)  -- true
```

---

# Find

To look for a certain substring in a string, `string.find(s, pattern)`

> Looks for the first match of pattern in the string `s`. If it finds a match, then `find` returns the indices of `s` where this occurrence starts and ends; otherwise, it returns nil.

```lua
s = "This is a beautiful day"

first,last = string.find(s, "is")
print(first,last)       -- 3   4

first,last = string.find(s, "beautiful")
print(first,last)       -- 11  19

first,last = string.find(s, "dinosaur")
print(first,last)       -- nil nil
```

**Note:** cannot use (yet) look for the characters `^$()%.[]*+-?`. We'll see later why.

---

# Find: start index

`string.find()` can take an additional parameter to indicate where to start the search: `string.find(s, pattern, init)`

```lua
s = "This is a beautiful day"

first,last = string.find(s, "is")
print(first,last)       -- 3   4

first,last = string.find(s, "is", 5)
print(first,last)       -- 6   7
```

---

# Replace

Search and replace: `string.gsub(s, pattern, repl)` (`gsub` stands for Global SUBstitution)

> Returns a copy of `s` in which all occurrences of `pattern` have been replaced by a replacement string `repl`. `gsub` also returns, as its second value, the total number of matches that occurred.

```lua
s = "We're having coffee, because coffee is nice!"

fixed, num = string.gsub(s, "coffee", "fun")
print(fixed)
print("Replaced " .. num .. " times")
```

Optional additional parameter `n`: replace only the first `n` occurences:

```lua
print(string.gsub("blah blah blah", "blah", "meh", 2))
```

---

# Mini exercises: strings

- write a function that takes a string, and return the array of all its letters: passing "Foo" would return `{"F", "o", "o"}`.
- write a function that takes a string, splits it into pieces of length 3, and returns them in an array. For instance, passing "What the hell?" would return `{"Wha", "t t", "he ", "hel", "l?"}`.
- write a function `find_all(s, sub)` that prints all the positions of a substring `sub` in a string `s`. For instance, `find_all("doo bi doo bi doo", "doo")` would print "1 3", "8 10" and "15 17".
- write a function that takes a string in which it replaces "dog" by "cat" and "awesome" by "evil", so that "All dogs are awesome" would become "All cats are evil".

---